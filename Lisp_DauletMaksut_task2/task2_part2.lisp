(setf input '(A (B (E (N) (O) (P)) (F (Q) (R) (S)) (G (T) (U) (V)))
 (C (H (W) (X) (Y)) (I (Z) (AA) (AB)) (J (AC) (AD) (AE)))
 (D (K (AF) (AG) (AH)) (L (AI) (AJ) (AK)) (M (AL) (AM) (AN))))  )
(print "Go and FUCK this shit")
(print (string= NIL '()))
(setf node "N")

(defun bfs (input)
	(setf parentName (first input))
	(format t "~S " parentName)
	(setf input (rest input))
	(setq depth 1)
	(let ((check NIL))
 		(loop do
 		(incf depth)
        (setf check (findRecursion input 1 depth parentName))
        while ( not check)
        )
 	)
)

(defun findRecursion (text currentLevel destinationLevel parentName)

	(incf currentLevel)
	(setf check NIL)
	(dolist (childs text)
		(format t "~S " (first childs))
		(if (/= currentLevel destinationLevel)
			(setf check (findRecursion (rest childs) currentlevel destinationLevel (first childs)))
		)
		(if (string= node (first childs))
			(return-from findRecursion T)
		)
		(if (= currentLevel destinationLevel)
			(format t "~S " parentName)
		)
		

	)
	(return-from findRecursion check)
)
(terpri)
(bfs input)